(defmacro fmt(&body b)
  `(progn
     ,@(mapcar (lambda(x) `(format t "~A~%" ,x)) b)))

(defclass koma()((pos :initarg :pos :accessor koma-pos)))
(defmethod koma-gety(koma) (cadr (koma-pos koma)))
(defmethod koma-getx(koma) (car (koma-pos koma)))
(defmethod tostr(koma) (format nil "~A ~A ~A" (koma-mark koma) (- 2 (koma-getx koma)) (koma-gety koma)))
(defmethod compute-pos(koma topos) (list (+ (koma-getx koma) (car topos)) (+ (koma-gety koma) (cadr topos))))
(defclass fu(koma) ())
(defclass ky(koma) ())
(defclass um(koma) ())
(defclass gn(koma) ())
(defclass kn(koma) ())
(defclass kk(koma) ())
(defclass hy(koma) ())
(defclass oh(koma) ())
(defmethod koma-mark((koma fu)) 'fu)
(defmethod koma-mark((koma ky)) 'ky)
(defmethod koma-mark((koma um)) 'um)
(defmethod koma-mark((koma gn)) 'gn)
(defmethod koma-mark((koma kn)) 'kn)
(defmethod koma-mark((koma kk)) 'kk)
(defmethod koma-mark((koma hy)) 'hy)
(defmethod koma-mark((koma oh)) 'oh)
(defmethod koma-moves((koma fu) sente) (if sente '((0 -1)) '((0 1))))
(defmethod koma-moves((koma ky) sente) (if sente '((0 -1) (0 -2)) '((0 1) (0 2))))
(defmethod koma-moves((koma um) sente) (if sente '((1 -2) (-1 -2)) '((1 2) (-1 2))))
(defmethod koma-moves((koma gn) sente) (if sente '((0 -1) (1 -1) (-1 -1) (1 1) (-1 1)) '((0 1) (1 1) (-1 1) (1 -1) (-1 -1))))
(defmethod koma-moves((koma kn) sente) (if sente '((0 -1) (1 -1) (-1 -1) (1 0) (-1 0) (0 1)) '((0 1) (1 1) (-1 1) (1 0) (-1 0) (0 -1))))
(defmethod koma-moves((koma kk) sente) '((1 -1) (2 -2) (-1 -1) (-2 -2) (1 1) (2 2) (-1 1) (-2 2)))
(defmethod koma-moves((koma hy) sente) '((1 0) (2 0) (-1 0) (-2 0) (0 1) (0 2) (0 1) (0 2)))
(defmethod koma-moves((koma oh) sente) '((0 1) (1 1) (1 0) (1 -1) (0 -1) (-1 -1) (-1 0) (-1 1)))
(defun make-koma(a pp)
  (let ((p (list (1- (car pp)) (1- (cadr pp)))))
    (make-instance a :pos p)))
(defmethod copy-koma ((koma fu)) (make-instance 'fu :pos (koma-pos koma)))
(defmethod copy-koma ((koma ky)) (make-instance 'ky :pos (koma-pos koma)))
(defmethod copy-koma ((koma um)) (make-instance 'um :pos (koma-pos koma)))
(defmethod copy-koma ((koma gn)) (make-instance 'gn :pos (koma-pos koma)))
(defmethod copy-koma ((koma kn)) (make-instance 'kn :pos (koma-pos koma)))
(defmethod copy-koma ((koma kk)) (make-instance 'kk :pos (koma-pos koma)))
(defmethod copy-koma ((koma hy)) (make-instance 'hy :pos (koma-pos koma)))
(defmethod copy-koma ((koma oh)) (make-instance 'oh :pos (koma-pos koma)))
(defmethod uterup((koma fu) pos) (find-if (lambda(x) (equal x pos)) '((0 1) (1 1) (2 1) (0 2) (1 2) (2 2))))
(defmethod uterup((koma ky) pos) (find-if (lambda(x) (equal x pos)) '((0 1) (1 1) (2 1) (0 2) (1 2) (2 2))))
(defmethod uterup((koma um) pos) (find-if (lambda(x) (equal x pos)) '((0 2) (1 2) (2 2))))
(defmethod uterup((koma gn) pos) (find-if (lambda(x) (equal x pos)) '((0 0) (1 0) (2 0) (0 1) (1 1) (2 1) (0 2) (1 2) (2 2))))
(defmethod uterup((koma kn) pos) (find-if (lambda(x) (equal x pos)) '((0 0) (1 0) (2 0) (0 1) (1 1) (2 1) (0 2) (1 2) (2 2))))
(defmethod uterup((koma kk) pos) (find-if (lambda(x) (equal x pos)) '((0 0) (1 0) (2 0) (0 1) (1 1) (2 1) (0 2) (1 2) (2 2))))
(defmethod uterup((koma hy) pos) (find-if (lambda(x) (equal x pos)) '((0 0) (1 0) (2 0) (0 1) (1 1) (2 1) (0 2) (1 2) (2 2))))
(defmethod ohtep((koma koma) topos sente komas) nil)
(defmethod ohtep((koma oh) topos sente komas)
  (let ((pos (compute-pos koma topos)))
    (find-if (lambda(k)
              (find-if (lambda(p)
                        (let ((pos0 (compute-pos k p)))
                          (equal pos pos0)))
                      (koma-moves koma sente)))
            komas)))

(defun fmtboard(komas0 komas1 sente)
  (labels ((rec (x y ks0 ks1)
                (cond ((and (null ks0) (null ks1)) "     ")
                      ((and (not (null ks0))
                            (= (koma-getx (car ks0)) x)
                            (= (koma-gety (car ks0)) y)) (format nil "~5A" (koma-mark (car ks0))))
                      ((and (not (null ks1))
                            (= (koma-getx (car ks1)) x)
                            (= (koma-gety (car ks1)) y)) (format nil "~5@A" (koma-mark (car ks1))))
                      (t (rec x y (cdr ks0) (cdr ks1))))))
    (dotimes (y 3)
      (dotimes (x 3)
        (when (zerop x)
          (format t "|"))
        (format t "~A" (rec x y (if sente komas0 komas1) (if sente komas1 komas0)))
        (format t "|"))
      (format t "~%")
      (dotimes (i 3) (format t "-------"))
      (format t "~%"))
    (format t "~%~%")))

(defun move-koma(koma topos komas0 komas1 mochi0 mochi1 callback)
  (let ((to (+ (* (+ (koma-gety koma) (cadr topos)) 3) (car topos) (koma-getx koma)))
        (pos (list (+ (koma-getx koma) (car topos)) (+ (koma-gety koma) (cadr topos)))))
    (when (and (< to (* 3 3)) (>= to 0) (< (car pos) 3) (>= (car pos) 0) (< (cadr pos) 3) (>= (cadr pos) 0))
      (let* ((k (copy-koma koma))
             (ks0 (reduce (lambda(acc x)
                            (if (equal (koma-pos x) (koma-pos k))
                              (cons k acc)
                              (cons x acc)))
                          komas0
                          :initial-value nil))
             (ks1 (reduce (lambda(acc x)
                            (if (equal (koma-pos x) pos)
                              (progn
                                (setf mochi0 (cons x mochi0))
                                acc)
                              (cons x acc)))
                          komas1
                          :initial-value nil)))
        (setf (koma-pos k) pos)
        (funcall callback ks0 ks1 mochi0 mochi1 (format nil "~A ~A ~A~%" (car pos) (cadr pos) (koma-mark koma)))))))

(defun movable-koma(koma topos komas0 komas1 sente)
  (let ((to (+ (* (+ (koma-gety koma) (cadr topos)) 3) (car topos) (koma-getx koma)))
        (pos (list (+ (koma-getx koma) (car topos)) (+ (koma-gety koma) (cadr topos)))))
    (if (and (< to (* 3 3)) (>= to 0) (< (car pos) 3) (>= (car pos) 0) (< (cadr pos) 3) (>= (cadr pos) 0))
      (labels ((pred (k)
                     (and (= (koma-gety k) (+ (koma-gety koma) (cadr topos))) (= (koma-getx k) (+ (koma-getx koma) (car topos))))))
        (and (not (find-if #'pred komas0))
             (not (ohtep koma topos sente komas1)))))))

(defun akimasu(komas0 komas1)
  (let ((r nil))
    (dotimes (y 3)
      (dotimes (x 3)
        (unless (or
                  (find-if (lambda(k)
                             (and (= (koma-getx k) x) (= (koma-gety k) y)))
                           komas0)
                  (find-if (lambda(k)
                             (and (= (koma-getx k) x) (= (koma-gety k) y)))
                           komas1))
          (setf r (cons (list x y) r)))))
    r))

(defun remove-if-one(pred lst)
  (labels ((rec (lst acc)
                (if (null lst)
                  acc
                  (if (funcall pred (car lst))
                    (append (cdr lst) acc)
                    (rec (cdr lst) (cons (car lst) acc))))))
    (rec lst nil)))
(defun akimasuutsu(koma komas0 komas1 mochi0 mochi1 depth sente acc0 acc1 kifu)
  (let ((ks0 (copy-tree komas0))
        (ks1 (copy-tree komas1)))
    (teban (cons koma ks0) ks1 (remove-if-one (lambda(x) (eq (koma-mark x) (koma-mark koma))) mochi0) mochi1 (1+ depth) sente acc0 acc1 kifu)))

(defun onethousandp(komas0 komas1 acc0 acc1)
  (labels ((toboard(ks b)
            (if (null ks)
              b
              (progn
                (setf (nth (+ (* (koma-gety (car ks)) 3) (koma-getx (car ks))) b) (koma-mark (car ks)))
                (toboard (cdr ks) b))))
           (rec (acc0 acc1 board)
                (if (null acc0)
                  nil
                  (let ((b (toboard (car acc1) (toboard (car acc0) (loop for i from 0 to 8 collect nil)))))
                    (if (equal board b)
                      t
                      (rec (cdr acc0) (cdr acc1) board))))))
    (rec acc0 acc1 (toboard komas1 (toboard komas0 (loop for i from 0 to 8 collect nil))))))

(defun teban(komas0 komas1 mochi0 mochi1 depth sente acc0 acc1 kifu)
  (when (< depth 5)
    (if (not (find-if (lambda(x) (eq (koma-mark x) 'oh)) komas0))
      (progn
        (when (not sente)
          (format t "~A~%" (if sente "lose" "win"))
          (let ((b t))
            (mapcar (lambda(a0 a1 a2)
                      (fmtboard a0 a1 b)
                      (format t "~A" a2)
                      (setf b (not b))
                      )
                    (reverse acc0) (reverse acc1) (reverse kifu)))
          (fmtboard komas0 komas1 sente)
          ))
      (if (onethousandp komas0 komas1 acc0 acc1)
        (progn
          (format t "one thousand~%")
          (let ((b t))
            (mapcar (lambda(a0 a1 a2)
                      (fmtboard a0 a1 b)
                      (format t "~A" a2)
                      (setf b (not b))
                    )
                  (reverse acc0) (reverse acc1) (reverse kifu)))
          (fmtboard komas0 komas1 sente)
          )
        (progn
          (mapcar (lambda(koma)
                    ;(fmt (tostr koma) (koma-moves koma sente))
                    (mapcar (lambda(pos)
                              (move-koma koma pos komas0 komas1 mochi0 mochi1 (lambda(ks0 ks1 mc0 mc1 te)
                                                                                ;(fmt mc0)
                                                                                ;(fmtboard ks0 ks1)
                                                                                (teban ks1 ks0 mc1 mc0 (1+ depth) (not sente) (cons komas0 acc0) (cons komas1 acc1) (cons te kifu)))))
                            (reduce (lambda(acc x)
                                      (if (movable-koma koma x komas0 komas1 sente)
                                        (cons x acc)
                                        acc))
                                    (koma-moves koma sente)
                                    :initial-value nil)))
                  komas0)
          (mapcar (lambda(k)
                    (mapcar (lambda(p)
                              ;(fmt p)
                              (setf (koma-pos k) p)
                              (akimasuutsu k komas0 komas1 mochi0 mochi1 depth (not sente) (cons komas0 acc0) (cons komas1 acc1) (cons (format nil "~A ~A ~A~%" (car p) (cadr p) (koma-mark k)) kifu))
                              )
                            (akimasu komas0 komas1)))
                  mochi0)
          )))))

(let* ((komas0 (list (make-koma 'fu '(1 3))
                     ;(make-koma 'ky '(2 3))
                     (make-koma 'oh '(3 3))))
       (komas1 (list (make-koma 'fu '(3 1))
                     ;(make-koma 'gn '(2 1))
                     (make-koma 'oh '(1 1)))))
  (fmtboard komas0 komas1 t)
  (teban komas0 komas1 nil nil 0 t nil nil nil)
  )
